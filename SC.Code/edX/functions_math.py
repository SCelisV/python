import math

def newLine():
    print()

# dot notation

angle = 1.0
print(f"- angle: {angle}")
x = -5.0
print(f"- x: {x}")
y = 10.0
print(f"- y: {y}")
z = 0.0
print(f"- z: {z}")
vacio = ""
print(f"- vacio: {vacio}")

print(f" - math.acos({angle}): {math.acos(angle)} - Return el coseno del arco (medido en radianes) de x")
newLine()
print(f" - math.acosh({angle}): {math.acosh(angle)} - Return el coseno hiperbólico inverso de x")
newLine()
print(f" - math.asin({angle}): {math.asin(angle)}  - Return el seno del arco (medido en radianes) de x")
newLine()
print(f" - math.asinh({angle}): {math.asinh(angle)} - Return el seno hiperbólico inverso de x")
newLine()
print(f" - math.atan({angle}): {math.atan(angle)} - Return el arco tangente (medido en radianes) de x")
newLine()
print(f" - math.atan2({y,x}): {math.atan2(y,x)} - Return el arco tangente (medido en radianes) de y/x. A diferencia de atan(y/x), se consideran los signos tanto de x como de y.")
newLine()
print(f" - math.atanh(0.5): {math.atanh(0.5)} - Return la tangente hiperbólica inversa de x")  
newLine()
print(f" - math.ceil({angle}): {math.ceil(angle)} - Return el techo de la x como una Integral. Este es el entero más pequeño >= x")
newLine()
print(f" - math.copysign({x,y}): {math.copysign(x,y)} - Return un float con el valor absoluto de x pero con el signo de y ")
newLine()
print(f" - math.cos({angle}): {math.cos(angle)} - Return el coseno de x (medido en radianes)")
newLine()
print(f" - math.cosh({angle}): {math.cosh(angle)}  - Return el coseno hiperbólico de x")
newLine()
print(f" - math.degrees({x}): {math.degrees(x)} - Convierte el ángulo de radianes a grados")
newLine()
print(f" - math.e: {math.e} - 2.718281828459045")
newLine()
print(f" - math.erf({x}): {math.erf(x)} - Función de error en x")
newLine()
print(f" - math.erfc({x}): {math.erfc(x)} - Función de error complementaria en x")
newLine()
print(f" - math.exp({x}): {math.exp(x)} - Return math.e elevado a la potencia de x ")
newLine()
print(f" - math.expm1({x}): {math.expm1(x)} - Esta función evita la pérdida de precisión que implica la evaluación directa de exp(x)-1 para el pequeño x")
newLine()
print(f" - math.fabs({x}): {math.fabs(x)} - Return el valor absoluto del float x")
newLine()
print(f" - math.factorial({math.fabs(x)}): {math.factorial(math.fabs(x))} - Return un int del factorial del valor absoluto de x")
newLine()
print(f" - math.floor({x}): {math.floor(x)} - Return el piso de x, el mayor entero menor o igual que x")
newLine()
print(f" - math.fmod({x,y}): {math.fmod(x,y)} - x % y puede ser diferente")
print(f" - x%y: {x%y}")
newLine()
print(f" - math.frexp({x}): {math.frexp(x)} - Devuelve la mantisa y el exponente de x, como par (m, e).")
print("m es un float y e es un int, tal que x = m * 2.**e")
print("Si x es 0, m y e son ambos 0")
print("Si no 0,5 <= abs(m) < 1,0")
newLine()
print(f"- x_list = [x/10] * 9: {[x/10] * 9}")
x_list = [x/10] * 9
print(f" - math.fsum({x_list}): - Return un float con la suma exacta del iterable de float pasado como argumento")
newLine()
print(f" - math.gamma({x/10}): {math.gamma(x/10)} - La función gamma en x")
newLine()
print(f" - math.gcd({int(x)},{int(y)}): {math.gcd(int(x),int(y))} - greatest common divisor of x and y => mayor divisor común de x e y")
newLine()
print(f" - math.hypot({x,y}): {math.hypot(x,y)} - hipotenusa de x, y")
newLine()
print(f" - math.inf: {math.inf} - inf float... npi")
newLine()
print(f" - math.isclose({x,y},rel_tol=1e-09, abs_tol=0.0): {math.isclose(x,y,rel_tol=1e-09, abs_tol=0.0)}")
print("Return Verdadero si los valores a y b son cercanos entre sí y Falso en caso contrario, la cercanía se determina según las tolerancias absolutas y relativas.")
print("rel_tol es la tolerancia relativa - es la diferencia máxima permitida entre a y b, relativa al mayor valor absoluto de a o b. Por ejemplo, para establecer una tolerancia del 5%, pasar rel_tol=0,05. La tolerancia por defecto es 1e-09, lo que asegura que los dos valores son iguales dentro de unos 9 dígitos decimales. rel_tol debe ser mayor que cero.")
print("abs_tol es la tolerancia mínima absoluta - útil para comparaciones cercanas a cero. abs_tol debe ser al menos cero.")
print("Si no se producen errores, el resultado será: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol).")
newLine()
print(f" - math.isfinite({x}): {math.isfinite(x)} - Return True if x is neither an infinity nor a NaN, and False otherwise")
newLine()
print(f" - math.isfinite({z}): {math.isfinite(z)} - Return True if x is neither an infinity nor a NaN, and False otherwise")
newLine()
print(f" - math.isfinite({math.nan}): {math.isfinite(math.nan)} - Return True if x is neither an infinity nor a NaN, and False otherwise")
# print(f" - math.isfinite(vacio): {math.isfinite(vacio)} - Return Verdadero si x no es ni un infinito ni un NaN, y Falso en caso contrario
newLine()
print(f" - math.isinf({x}): {math.isinf(x)} - Return Verdadero si x es un infinito positivo o negativo, y Falso en caso contrario.")
newLine()
print(f" - math.isnan({x}): {math.isnan(x)} - Return Verdadero si x es un NaN (no un número), y Falso en caso contrario")
newLine()
print(f" - math.isnan({math.nan}): {math.isnan(math.nan)} - Return Verdadero si x es un NaN (no un número), y Falso en caso contrario")
newLine()
print(f" - math.ldexp({x},{int(y)}): {math.ldexp(x,int(y))} - Esto es esencialmente el inverso de frexp(). Return x * (2**i).")
print(f"x * (2**int(y)): {x * (2**int(y))}")
newLine()
print(f" - math.lgamma({math.fabs(x)}): {math.lgamma(math.fabs(x))} - Logaritmo natural de valor absoluto de la función Gamma en x")
newLine()
print(f" - math.log({math.fabs(x)}): {math.log(math.fabs(x))} - Return el logaritmo de x a la base dada => log(x, [base=math.e])")
print("Si la base no está especificada, return el logaritmo natural (base e) de x")
newLine()
print(f" - math.log10({math.fabs(x)}): {math.log10(math.fabs(x))} - Return el logaritmo de x en base 10") 
newLine()
print(f" - math.log1p({math.fabs(x)}): {math.log1p(math.fabs(x))} - Return el logaritmo natural de 1+x (base e)")
print("El resultado se calcula de forma que sea exacto para x cerca de cero")
newLine()
print(f" - math.log2({math.fabs(x)}): {math.log2(math.fabs(x))} - Return el logaritmo de x en base 2")
newLine()
print(f" - math.modf({x}): {math.modf(x)} - Return tanto la parte entera com la facción de x.")
print("Ambos resultados llevan el signo de x y son float.")
newLine()
print(f" - math.nan: {math.nan}")
newLine()
print(f" - math.pi: {math.pi}")
newLine()
print(f" - math.pow({x,y}): {math.pow(x,y)} - Return x**y (x elevado a y). ")
newLine()
print(f" - math.radians({angle}): {math.radians(angle)} - Convierte grados a radianes")
newLine()
print(f" - math.remainder({x,y}): {math.remainder(x,y)} - Diferencia entre x y el múltiplo entero más cercano de y")
print("Return x - n*y donde n*y es el múltiplo entero más cercano de y. En el caso de que x esté exactamente a mitad de camino entre dos múltiplos de y, se utiliza el valor par más cercano de n. El resultado es siempre exacto.")
newLine()
print(f" - math.sin({angle}): {math.sin(angle)} - Return el seno de x (medido en radianes)")
newLine()
print(f" - math.sinh({angle}): {math.sinh(angle)} - Return el seno hiperbólico de x.")
newLine()
print(f" - math.sqrt({math.fabs(x)}): {math.sqrt(math.fabs(x))} - Return la raíz cuadrada de x.")
newLine()
print(f" - math.tan({x}): {math.tan(x)} - Return la tangente de x (medida en radianes) ")
newLine()
print(f" - math.tanh({x}): {math.tanh(x)} - Return la tangente hiperbólica de x")
newLine()
print(f" - math.tau: {math.tau} - ")
newLine()
print(f" - math.trunc({x}): {math.trunc(x)} - Trunca el Real x a la Integral más cercana hacia 0")
newLine()
print(f" - math.__doc__: {math.__doc__}")
newLine()
print(f" - math.__file__: {math.__file__}") 
newLine()
print(f" - math.__name__: {math.__name__}") 
newLine()
print(f" - math.__package__: {math.__package__}")
newLine()